// SPDX-License-Identifier: GPL-2.0

/*
 * Copyright 2024 Disilicon 
 *
 * Nuclei Basic Timer 
 *
 */

#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/io.h>
#include <linux/rtc.h>
#include <linux/clk.h>
#include <linux/bcd.h>
#include <linux/bitfield.h>
#include <linux/interrupt.h>
#include <linux/pm_wakeirq.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/poll.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>
#include <linux/atomic.h>

/* Registers */
#define NUCLEI_CR1		0x00
#define NUCLEI_CR2		0x04
#define NUCLEI_DIER		0x0C
#define NUCLEI_SR		0x10
#define NUCLEI_EGR		0x14
#define NUCLEI_CNT		0x24
#define NUCLEI_PSC		0x28
#define NUCLEI_ARR		0x2C

/* ===== TIMER_CR1 ===== */
#define TIMER_CR1_CEN                   BIT(0)                                /*!< TIMER counter enable */
#define TIMER_CR1_UDIS                  BIT(1)                                /*!< update disable */
#define TIMER_CR1_URS                   BIT(2)                                /*!< update source */
#define TIMER_CR1_OPM                   BIT(3)                                /*!< one pulse mode */
#define TIMER_CR1_ARPE                  BIT(7)                                /*!< auto-reload preload enable */

/* ===== TIMER_CR2 ===== */
#define TIMER_CR2_MMS                   GENMASK(6,4)                          /*!< master mode selection */

/* ===== TIMER_DIER ===== */
#define TIMER_DIER_UIE                  BIT(0)                                /*!< update interrupt enable */
#define TIMER_DIER_UDE                  BIT(8)                                /*!< update DMA request enable */

/* ===== TIMER_SR ===== */
#define TIMER_SR_UIF                    BIT(0)                                /*!< update interrupt flag */

/* ===== TIMER_EGR ===== */
#define TIMER_EGR_UG                    BIT(0)                                /*!< update generation */

/* ===== TIMER_CNT ===== */
#define TIMER_CNT_CNT                   GENMASK(31,0)                         /*!< counter value */

/* ===== TIMER_PSC ===== */
#define TIMER_PSC_PSC                   GENMASK(31,0)                         /*!< prescaler value */

/* ===== TIMER_ARR ===== */
#define TIMER_ARR_ARR                   GENMASK(31,0)                         /*!< auto reload value */

/* TIMER interrupt enable or disable */
#define TIMER_INT_UP                    TIMER_DIER_UIE                        /*!< update interrupt */

/* TIMER interrupt flag */
#define TIMER_INT_FLAG_UP               TIMER_INT_UP                          /*!< update interrupt */

/* TIMER flag */
#define TIMER_FLAG_UP                   TIMER_SR_UIF                          /*!< update flag */

/* TIMER DMA source enable */
#define TIMER_DMA_UPD                   ((uint32_t)TIMER_DIER_UDE)            /*!< update DMA enable */

 /* ===== BASIC TIMER EGR Register definition ===== */
#define BASIC_TIMER_EGR_UG                           BIT(0)                                      /*!< Update generation This bit can be set by software, it is automatically cleared by hardware. -1'b0: No action -1'b1: Update event is generated by software */
#define BASIC_TIMER_EGR_UG_OFS                       0U                                          /*!< BASIC TIMER EGR: UG Bit Offset */
#define BASIC_TIMER_EGR_UG_VAL(regval)               (BIT(0) & ((uint32_t)(regval) << 0))        /*!< BASIC TIMER EGR: UG Bit Value */  
#define BASIC_TIMER_EGR_UG_NO                        0x0UL                                       /*!< NO */
#define BASIC_TIMER_EGR_UG_UPDATE                    BIT(0)                                      /*!< UPDATE */

#define BASIC_TIMER_CR1_AUTO_BUFFER_EN               BIT(7)                                      /*!< Auto-buffer enable -1'b0:    disabled: TIMx_ARR register is not buffered -1'b1:    enabled:TIMx_ARR register is buffered */
#define BASIC_TIMER_CR1_AUTO_BUFFER_EN_OFS           7U                                          /*!< BASIC TIMER CR1: AUTO_BUFFER_EN Bit Offset */
#define BASIC_TIMER_CR1_AUTO_BUFFER_EN_VAL(regval)   (BIT(7) & ((uint32_t)(regval) << 7))        /*!< BASIC TIMER CR1: AUTO_BUFFER_EN Bit Value */  
#define BASIC_TIMER_CR1_AUTO_BUFFER_EN_DISABLED      0x0UL                                       /*!< DISABLED */
#define BASIC_TIMER_CR1_AUTO_BUFFER_EN_ENABLED       BIT(7)                                      /*!< ENABLED */

/* ===== BASIC TIMER CR1 Register definition ===== */
#define BASIC_TIMER_CR1_CEN                          BIT(0)                                      /*!< Counter enable -1'b0:    Counter_disabled: Counter disabled -1'b1:    Counter_enabled: Counter enabled Note: when an update event occurs. This bit is cleared automatically in one-pulse mode. */
#define BASIC_TIMER_CR1_CEN_OFS                      0U                                          /*!< BASIC TIMER CR1: CEN Bit Offset */
#define BASIC_TIMER_CR1_CEN_VAL(regval)              (BIT(0) & ((uint32_t)(regval) << 0))        /*!< BASIC TIMER CR1: CEN Bit Value */  
#define BASIC_TIMER_CR1_CEN_COUNTER_DISABLED         0x0UL                                       /*!< COUNTER_DISABLED */
#define BASIC_TIMER_CR1_CEN_COUNTER_ENABLED          BIT(0)                                      /*!< COUNTER_ENABLED */

#define PRESCALER 124

static int nuclei_rtc_device_count = 0;  // 静态设备计数器
static struct class *nuclei_rtc_class = NULL;  // 全局class，所有设备共享

struct nuclei_rtc {
	struct rtc_device *rtc_dev;
	struct clk *pclk;
	void __iomem *regs;
	int irq;
    char irq_name[32];
	/* 字符设备相关字段 */
	struct cdev cdev;
	struct device *chr_dev;
	dev_t dev_num;
	wait_queue_head_t wait_queue;
	unsigned long irq_count;
	bool irq_pending;
	struct mutex irq_lock;
	/* 设备特定字段 */
	unsigned long clock_g;
	uint32_t period;
	uint32_t counter;
	uint8_t irq_flag;
	int device_id;  // 设备ID
};

/* 内联函数：写寄存器 */
static inline void nuclei_rtc_writereg(struct nuclei_rtc *crtc, u32 reg, u32 val)
{
	writel(val, crtc->regs + reg);
}

/* 内联函数：读寄存器 */
static inline u32 nuclei_rtc_readreg(struct nuclei_rtc *crtc, u32 reg)
{
	return readl(crtc->regs + reg);
}

static irqreturn_t nuclei_rtc_irq_handler(int irq, void *id)
{
    struct nuclei_rtc *crtc = id; 
    
    if(crtc->irq_flag == 0) {
        crtc->irq_flag = 1;
        return IRQ_HANDLED;
    }

	/* clear the interrupt pending */
	nuclei_rtc_writereg(crtc, NUCLEI_SR, (u32)~TIMER_INT_UP);

    /* 更新中断计数和状态 */
    mutex_lock(&crtc->irq_lock);
    crtc->irq_count++;
    crtc->irq_pending = true;
    mutex_unlock(&crtc->irq_lock);

    /* 唤醒等待的用户进程 */
    wake_up_interruptible(&crtc->wait_queue);

    /* user can do the irq handler here */
    /* end of irq handler */

	rtc_update_irq(crtc->rtc_dev, 1, RTC_IRQF | RTC_AF);
	return IRQ_HANDLED;
}

/* When the update event is set, send interrupt */
static int nuclei_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
{
	struct nuclei_rtc *crtc = dev_get_drvdata(dev);

	if (enabled) {
        nuclei_rtc_writereg(crtc, NUCLEI_DIER, TIMER_INT_UP);
	} else {
        	nuclei_rtc_writereg(crtc, NUCLEI_DIER, (u32)~TIMER_INT_UP);
	}

	return 0;
}
/* 字符设备操作函数 */
static int nuclei_rtc_open(struct inode *inode, struct file *file)
{
	struct nuclei_rtc *crtc = container_of(inode->i_cdev, struct nuclei_rtc, cdev);
	
	file->private_data = crtc;
	return 0;
}

static int nuclei_rtc_release(struct inode *inode, struct file *file)
{
	
	return 0;
}

static ssize_t nuclei_rtc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
	struct nuclei_rtc *crtc = file->private_data;
	unsigned long irq_count;
	int ret;

	if (count < sizeof(unsigned long))
		return -EINVAL;

	/* 等待中断发生 */
	ret = wait_event_interruptible(crtc->wait_queue, crtc->irq_pending);
	if (ret)
		return ret;

	mutex_lock(&crtc->irq_lock);
	irq_count = crtc->irq_count;
	crtc->irq_pending = false;
	mutex_unlock(&crtc->irq_lock);

	if (copy_to_user(buf, &irq_count, sizeof(unsigned long)))
		return -EFAULT;

	return sizeof(unsigned long);
}

static unsigned int nuclei_rtc_poll(struct file *file, poll_table *wait)
{
	struct nuclei_rtc *crtc = file->private_data;
	unsigned int mask = 0;

	poll_wait(file, &crtc->wait_queue, wait);
	mutex_lock(&crtc->irq_lock);
	if (crtc->irq_pending)
		mask |= POLLIN;
	mutex_unlock(&crtc->irq_lock);

	return mask;  //内核会匹配每个设备的返回值与用户设置的events，如果都不匹配，线程就会在poll()中阻塞，等待唤醒后，再次执行这个函数
}

/* 保留原有的RTC ioctl函数 */
static int nuclei_rtc_ioctl(struct device *dev, unsigned int cmd,
			     unsigned long arg)
{
	struct nuclei_rtc *crtc = dev_get_drvdata(dev);
    uint32_t tmp = 0;
	switch (cmd) {
	    case RTC_VL_READ:
              /* configure the counter prescaler value */
             nuclei_rtc_writereg(crtc, NUCLEI_PSC, PRESCALER);
             /* configure the autoreload value */
             crtc->clock_g = clk_get_rate(crtc->pclk);
             crtc->period = crtc->clock_g / PRESCALER /1000000 * crtc->counter;
             nuclei_rtc_writereg(crtc, NUCLEI_ARR, crtc->period-1);
             /* generate an update event */
             tmp = nuclei_rtc_readreg(crtc, NUCLEI_EGR);
             nuclei_rtc_writereg(crtc, NUCLEI_EGR, tmp|(uint32_t)BASIC_TIMER_EGR_UG);
             /* enable the auto reload shadow function */
             tmp = nuclei_rtc_readreg(crtc, NUCLEI_CR1);
             nuclei_rtc_writereg(crtc, NUCLEI_CR1, tmp|(uint32_t)BASIC_TIMER_CR1_AUTO_BUFFER_EN);
             /* clear the interrupt pending*/
	        nuclei_rtc_writereg(crtc, NUCLEI_SR, (u32)~TIMER_INT_UP);
             /* enable irq */
             nuclei_rtc_alarm_irq_enable(dev, 1);
             /* timer enable */
             tmp = nuclei_rtc_readreg(crtc, NUCLEI_CR1);
             nuclei_rtc_writereg(crtc, NUCLEI_CR1, tmp|(uint32_t)BASIC_TIMER_CR1_CEN);
		        
		        return 0;

        case RTC_VL_CLR:
            crtc->irq_flag = 0;
            tmp = nuclei_rtc_readreg(crtc, NUCLEI_CR1);
            /* disable timer */
            nuclei_rtc_writereg(crtc, NUCLEI_CR1, tmp&(~(uint32_t)BASIC_TIMER_CR1_CEN));
            /* disable irq */
	        nuclei_rtc_alarm_irq_enable(dev, 0);
            /* clear the interrupt pending*/
	        nuclei_rtc_writereg(crtc, NUCLEI_SR, (u32)~TIMER_INT_UP);
            rtc_update_irq(crtc->rtc_dev, 1, RTC_IRQF | RTC_AF);

	        return 0;

		default:
		    return -ENOIOCTLCMD;
	}
}

static const struct file_operations nuclei_rtc_fops = {
	.owner = THIS_MODULE,
	.open = nuclei_rtc_open,
	.release = nuclei_rtc_release,
	.read = nuclei_rtc_read,
	.poll = nuclei_rtc_poll,
};

static const struct rtc_class_ops nuclei_rtc_ops = {
    .ioctl = nuclei_rtc_ioctl,
	.alarm_irq_enable = nuclei_rtc_alarm_irq_enable,
};

static int nuclei_rtc_probe(struct platform_device *pdev)
{
	struct nuclei_rtc *crtc;
	int ret;
	char dev_name[32];

	crtc = devm_kzalloc(&pdev->dev, sizeof(*crtc), GFP_KERNEL);  // 分配驱动私有数据结构内存
	if (!crtc)
		return -ENOMEM;

	crtc->regs = devm_platform_ioremap_resource(pdev, 0);  // 映射硬件寄存器地址到虚拟地址空间
	if (IS_ERR(crtc->regs))
		return PTR_ERR(crtc->regs);

	crtc->irq = platform_get_irq(pdev, 0);  // 获取设备的中断号
	if (crtc->irq < 0)
		return -EINVAL;

	crtc->pclk = devm_clk_get(&pdev->dev, NULL);  // 获取设备的时钟
	if (IS_ERR(crtc->pclk)) {
		ret = PTR_ERR(crtc->pclk);
		dev_err(&pdev->dev,
			"missing clock\n");
		return ret;
	}

	crtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);  // 分配RTC设备结构
	if (IS_ERR(crtc->rtc_dev))
		return PTR_ERR(crtc->rtc_dev);

	/* 初始化字符设备相关字段 */
	init_waitqueue_head(&crtc->wait_queue);
	mutex_init(&crtc->irq_lock);
	crtc->irq_count = 0;
	crtc->irq_pending = false;

	/* 设置设备ID */
	crtc->device_id = nuclei_rtc_device_count++;  // 使用静态计数器
	crtc->counter = 1000000;  // 默认值
	crtc->irq_flag = 0;
    snprintf(crtc->irq_name, sizeof(crtc->irq_name), "nuclei_rtc%d", crtc->device_id);
	

    platform_set_drvdata(pdev, crtc);

	/* 分配字符设备号 */
	ret = alloc_chrdev_region(&crtc->dev_num, 0, 1, "nuclei_rtc");  // 为字符设备分配主次设备号 （注册到内核设备管理系统）
	if (ret) {
		dev_err(&pdev->dev, "Failed to allocate device number\n");
		return ret;  // 修复：分配设备号失败时直接返回，无需清理
	}

	/* 初始化字符设备 */
	cdev_init(&crtc->cdev, &nuclei_rtc_fops);  // 初始化字符设备结构体
	crtc->cdev.owner = THIS_MODULE;

	/* 添加字符设备 */
	ret = cdev_add(&crtc->cdev, crtc->dev_num, 1);  // 将字符设备添加到内核设备系统
	if (ret) {
		dev_err(&pdev->dev, "Failed to add character device\n");
		goto err_unregister_chrdev;
	}

	/* 创建设备节点 */
	if (!nuclei_rtc_class) {
		nuclei_rtc_class = class_create("nuclei_rtc");
		if (IS_ERR(nuclei_rtc_class)) {
			printk("Failed to create class\n");
			ret = PTR_ERR(nuclei_rtc_class);
			nuclei_rtc_class = NULL;
			goto err_del_cdev;
		}
	}
	snprintf(dev_name, sizeof(dev_name), "nuclei_rtc%d", crtc->device_id);
	crtc->chr_dev = device_create(nuclei_rtc_class, &pdev->dev, crtc->dev_num, NULL, dev_name);  // 在/dev目录下创建设备文件
	if (IS_ERR(crtc->chr_dev)) {
		ret = PTR_ERR(crtc->chr_dev);
		dev_err(&pdev->dev, "Failed to create device node\n");
		goto err_del_cdev;  // 不销毁class，因为可能有其他设备在使用
	}

	ret = clk_prepare_enable(crtc->pclk);  // 准备并启用设备时钟
	if (ret) {
		dev_err(&pdev->dev,
			"failed to enable clock\n");
		goto err_disable_pclk;
	}

    /* clear the interrupt pending*/
	nuclei_rtc_writereg(crtc, NUCLEI_SR, (u32)~TIMER_INT_UP);  // 清除中断待处理标志

	/* register interrupt handler */
    ret = devm_request_irq(&pdev->dev, crtc->irq,
                   nuclei_rtc_irq_handler, 0,
                   crtc->irq_name, crtc);  // 注册中断处理函数到内核，使用持久化名称并传 crtc
	if (ret) {
		dev_err(&pdev->dev,
			"Failed to request interrupt for the device, %d\n",
			ret);
		goto err_disable_pclk; 
	}
	
    of_property_read_u32(pdev->dev.of_node, "counter-value", &crtc->counter);  // 从设备树读取计数器值

/* enable interrupt in kernel driver, otherwise user need to enable interrupt in userspace by ioctl */
#ifdef ENABLE_INT
    uint32_t tmp;  // 将变量声明移到块开始
    
    /* set default period from dts */
    /* configure the counter prescaler value */
    nuclei_rtc_writereg(crtc, NUCLEI_PSC, PRESCALER);  // 设置定时器预分频值
    /* configure the autoreload value */
    crtc->clock_g = clk_get_rate(crtc->pclk);  // 获取时钟频率
    crtc->period = crtc->clock_g / PRESCALER /1000000 * crtc->counter;  // 计算定时器周期
    nuclei_rtc_writereg(crtc, NUCLEI_ARR, crtc->period-1);  // 设置定时器自动重载值
    /* generate an update event */
    tmp = nuclei_rtc_readreg(crtc, NUCLEI_EGR);  // 使用新的读寄存器函数
    nuclei_rtc_writereg(crtc, NUCLEI_EGR, tmp|(uint32_t)BASIC_TIMER_EGR_UG);  // 生成更新事件
    /* enable the auto reload shadow function */
    tmp = nuclei_rtc_readreg(crtc, NUCLEI_CR1);  // 使用新的读寄存器函数
    nuclei_rtc_writereg(crtc, NUCLEI_CR1, tmp|(uint32_t)BASIC_TIMER_CR1_AUTO_BUFFER_EN);  // 启用自动重载缓冲功能
    //enable irq
    nuclei_rtc_alarm_irq_enable(&pdev->dev, 1);  // 修复：使用1启用中断
    //timer enable
    tmp = nuclei_rtc_readreg(crtc, NUCLEI_CR1);  // 使用新的读寄存器函数
    nuclei_rtc_writereg(crtc, NUCLEI_CR1, tmp|(uint32_t)BASIC_TIMER_CR1_CEN);  // 启用定时器
#endif

	crtc->rtc_dev->ops = &nuclei_rtc_ops;  // 设置RTC设备操作函数
	
	ret = devm_rtc_register_device(crtc->rtc_dev);  // 注册RTC设备到内核
	if (ret) {
		dev_err(&pdev->dev, "Failed to register RTC device\n");
		goto err_disable_pclk;  // RTC注册失败，直接跳转到时钟清理
	}

	ret = device_init_wakeup(&pdev->dev, true);  // 初始化设备唤醒功能
	if (ret) {
		dev_err(&pdev->dev, "Failed to initialize wakeup\n");
		goto err_disable_wakeup;  
	}

	return 0;

err_disable_wakeup:
	device_init_wakeup(&pdev->dev, false);

err_disable_pclk:
	clk_disable_unprepare(crtc->pclk);
    /* 如果已经创建了 /dev 节点，则销毁之，避免 /dev 存在但中断未注册的异常状态 */
    if (!IS_ERR_OR_NULL(crtc->chr_dev))
        device_destroy(nuclei_rtc_class, crtc->dev_num);

err_del_cdev:
	cdev_del(&crtc->cdev);

err_unregister_chrdev:
	unregister_chrdev_region(crtc->dev_num, 1);

	return ret;
}

static int nuclei_rtc_remove(struct platform_device *pdev)
{
	struct nuclei_rtc *crtc = platform_get_drvdata(pdev);

	/* 清理字符设备 */
	device_destroy(nuclei_rtc_class, crtc->dev_num);
	cdev_del(&crtc->cdev);
	unregister_chrdev_region(crtc->dev_num, 1);

	nuclei_rtc_alarm_irq_enable(&pdev->dev, 0);
	device_init_wakeup(&pdev->dev, false);
	clk_disable_unprepare(crtc->pclk);

	return 0;
}

static const struct of_device_id nuclei_rtc_of_match[] = {
	{ .compatible = "nuclei,rtc" },
	{ },
};
MODULE_DEVICE_TABLE(of, nuclei_rtc_of_match);

static struct platform_driver nuclei_rtc_driver = {
	.driver = {
		.name = "nuclei-rtc",
		.of_match_table = nuclei_rtc_of_match,
	},
	.probe = nuclei_rtc_probe,
	.remove = nuclei_rtc_remove,
};
module_platform_driver(nuclei_rtc_driver);

MODULE_AUTHOR("cao.jiasheng@disilicon.com");
MODULE_DESCRIPTION("Nuclei Basic Timer driver");
MODULE_LICENSE("GPL v2");

